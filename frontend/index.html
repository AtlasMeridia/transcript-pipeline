<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0e1318">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Transcript Pipeline</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400;1,500&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=IBM+Plex+Mono:wght@400;500&family=JetBrains+Mono:wght@400;500&family=Lora:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
  <!-- Privacy-respecting analytics (Issue #8) - Update data-domain to match your Plausible account -->
  <script defer data-domain="transcript.atlasm.net" src="https://plausible.io/js/script.js"></script>
  <style>
    :root {
      /* ═══════════════════════════════════════════════════════════════
         ATLAS MERIDIA DESIGN TOKENS v3.1
         ═══════════════════════════════════════════════════════════════ */

      /* Navy Scale — desaturated, slightly warm */
      --navy-950: #08090c;
      --navy-900: #0e1318;
      --navy-800: #161c24;
      --navy-700: #1e2630;
      --navy-600: #2a3440;
      --navy-500: #3d4754;

      /* Cream Scale — for light mode and accents */
      --cream-50: #f8f6f1;
      --cream-100: #f3f0ea;

      /* Background tokens */
      --bg-primary: var(--navy-900);
      --bg-secondary: var(--navy-800);
      --bg-elevated: var(--navy-700);
      --bg-card: rgba(22, 28, 36, 0.8);
      --bg-deep: var(--navy-950);

      /* Text colors — refined cream tones (WCAG AA compliant) */
      --text-primary: #d5cab8;    /* 11.5:1 contrast on navy-900 */
      --text-secondary: #bfb4a4;  /* 9.1:1 contrast on navy-900 */
      --text-muted: #a89d8e;      /* 6.5:1 contrast on navy-900, 5.3:1 on navy-700 */

      /* Amber-Gold Accent Scale */
      --accent-light: #ddb878;
      --accent: #c9924a;
      --accent-dark: #a87a3a;
      --accent-deep: #8a6530;
      --accent-gold: var(--accent);
      --accent-gold-dim: rgba(201, 146, 74, 0.6);
      --accent-gold-subtle: rgba(201, 146, 74, 0.15);
      --accent-gold-glow: rgba(201, 146, 74, 0.08);

      /* Status colors — softened */
      --success: #6a9a70;
      --success-subtle: rgba(106, 154, 112, 0.15);
      --error: #b05454;
      --error-subtle: rgba(176, 84, 84, 0.15);
      --info: #5c8ac4;

      /* Borders — using navy scale */
      --border-subtle: rgba(42, 52, 64, 0.5);
      --border-light: var(--navy-600);
      --border-color: var(--navy-600);

      /* Typography */
      --font-display: 'Cormorant Garamond', Georgia, serif;
      --font-serif: 'Cormorant Garamond', Georgia, serif;
      --font-body: 'Lora', Georgia, serif;
      --font-sans: 'DM Sans', -apple-system, sans-serif;
      --font-ui: 'DM Sans', system-ui, sans-serif;
      --font-mono: 'IBM Plex Mono', 'JetBrains Mono', monospace;

      /* Motion tokens */
      --transition-fast: 150ms ease;
      --transition-base: 300ms ease;
      --transition-slow: 600ms cubic-bezier(0.16, 1, 0.3, 1);
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);

      /* Border radius */
      --border-radius-sm: 4px;
      --border-radius: 6px;
      --border-radius-lg: 12px;

      /* Spacing */
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 40px;
      --space-2xl: 64px;
      --space-3xl: 96px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    ::selection {
      background: rgba(201, 146, 74, 0.3);
      color: inherit;
    }

    /* Noise texture overlay */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 9999;
    }

    ::placeholder {
      color: var(--text-muted);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--text-muted);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* ═══════════════════════════════════════════════════════════════
       MOBILE-FIRST RESPONSIVE STYLES (Issue #7)
       ═══════════════════════════════════════════════════════════════ */

    /* Touch-friendly targets (min 44x44px) */
    @media (max-width: 768px) {
      html {
        font-size: 15px;
      }

      /* Ensure minimum touch target sizes */
      button, a, input[type="text"] {
        min-height: 44px;
      }

      /* Stack layouts vertically */
      .mobile-stack {
        flex-direction: column !important;
      }

      /* Full-width inputs on mobile */
      .mobile-full-width {
        width: 100% !important;
      }
    }

    @media (max-width: 480px) {
      html {
        font-size: 14px;
      }
    }

    /* Smooth transitions for keyboard appearance */
    @media (max-height: 500px) {
      .hero-section {
        padding-top: var(--space-lg) !important;
        padding-bottom: var(--space-md) !important;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React and Babel for development -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef, useCallback } = React;

    // ============================================================================
    // Configuration
    // ============================================================================

    const API_BASE_URL = window.location.origin;

    // ============================================================================
    // API Client
    // ============================================================================

    const api = {
      async startProcessing(url, options = {}) {
        const response = await fetch(`${API_BASE_URL}/api/process`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            url,
            llm_type: options.llmType,
            extract: options.extract !== false,
          }),
        });
        if (!response.ok) throw new Error('Failed to start processing');
        return response.json();
      },

      streamJobStatus(jobId, onUpdate, onComplete, onError) {
        const eventSource = new EventSource(`${API_BASE_URL}/api/jobs/${jobId}/stream`);

        eventSource.onmessage = (event) => {
          const data = JSON.parse(event.data);
          onUpdate(data);

          if (data.status === 'complete' || data.status === 'error') {
            eventSource.close();
            onComplete(data);
          }
        };

        eventSource.onerror = (error) => {
          eventSource.close();
          onError(error);
        };

        return () => eventSource.close();
      },

      getDownloadUrl(jobId, fileType) {
        return `${API_BASE_URL}/api/jobs/${jobId}/download/${fileType}`;
      },

      async getConfig() {
        const response = await fetch(`${API_BASE_URL}/api/config`);
        if (!response.ok) throw new Error('Failed to get config');
        return response.json();
      },

      async getTranscript(jobId) {
        const response = await fetch(`${API_BASE_URL}/api/jobs/${jobId}/transcript`);
        if (!response.ok) throw new Error('Failed to fetch transcript');
        const data = await response.json();
        return data.content;
      },

      async getSummary(jobId) {
        const response = await fetch(`${API_BASE_URL}/api/jobs/${jobId}/summary`);
        if (!response.ok) return null;  // Summary may not exist
        const data = await response.json();
        return data.content;
      },
    };

    // ============================================================================
    // Styles (CSS-in-JS)
    // ============================================================================

    // Detect mobile viewport
    const isMobile = () => window.innerWidth <= 768;

    const styles = {
      // Layout
      container: {
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
      },

      // Header
      header: {
        position: 'sticky',
        top: 0,
        zIndex: 100,
        background: 'rgba(14, 19, 24, 0.9)',
        backdropFilter: 'blur(12px)',
        borderBottom: '1px solid var(--border-subtle)',
      },
      headerInner: {
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '0 var(--space-lg)',
        height: '60px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
      },
      logo: {
        fontFamily: 'var(--font-display)',
        fontSize: '1.25rem',
        fontWeight: 500,
        fontStyle: 'italic',
        color: 'var(--text-primary)',
        letterSpacing: '-0.01em',
      },
      nav: {
        display: 'flex',
        gap: 'var(--space-lg)',
        alignItems: 'center',
      },
      navLink: {
        fontFamily: 'var(--font-ui)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        textDecoration: 'none',
        transition: 'color 0.2s ease',
        cursor: 'pointer',
      },
      navLinkActive: {
        color: 'var(--text-primary)',
      },
      statusDot: {
        width: '6px',
        height: '6px',
        borderRadius: '50%',
        display: 'inline-block',
        marginRight: '6px',
      },

      // Hero section
      hero: {
        padding: 'clamp(var(--space-xl), 8vw, var(--space-3xl)) var(--space-lg)',
        maxWidth: '1200px',
        margin: '0 auto',
        width: '100%',
      },
      heroContent: {
        maxWidth: '720px',
      },
      heroTitle: {
        fontFamily: 'var(--font-display)',
        fontSize: 'clamp(2rem, 5vw, 3.5rem)',
        fontWeight: 400,
        lineHeight: 1.15,
        marginBottom: 'var(--space-md)',
        color: 'var(--text-primary)',
      },
      heroTitleAccent: {
        background: 'linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 100%)',
        WebkitBackgroundClip: 'text',
        WebkitTextFillColor: 'transparent',
        backgroundClip: 'text',
      },
      heroSubtitle: {
        fontFamily: 'var(--font-display)',
        fontSize: 'clamp(1rem, 2.5vw, 1.25rem)',
        fontStyle: 'italic',
        color: 'var(--text-secondary)',
        lineHeight: 1.5,
      },

      // Main content
      main: {
        flex: 1,
        padding: '0 var(--space-md) var(--space-2xl)',
        maxWidth: '1200px',
        margin: '0 auto',
        width: '100%',
      },

      // Input section
      inputSection: {
        marginBottom: 'var(--space-xl)',
      },
      inputLabel: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        textTransform: 'uppercase',
        letterSpacing: '0.1em',
        color: 'var(--text-muted)',
        marginBottom: 'var(--space-sm)',
        display: 'block',
      },
      inputWrapper: {
        display: 'flex',
        gap: 'var(--space-md)',
        alignItems: 'stretch',
        flexDirection: 'row',
      },
      inputWrapperMobile: {
        flexDirection: 'column',
      },
      input: {
        flex: 1,
        background: 'var(--bg-secondary)',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-lg)',
        fontFamily: 'var(--font-ui)',
        fontSize: '1rem',
        color: 'var(--text-primary)',
        outline: 'none',
        transition: 'border-color var(--transition-fast), box-shadow var(--transition-fast)',
        minHeight: '48px',
      },
      inputFocused: {
        borderColor: 'var(--accent)',
        boxShadow: '0 0 0 3px rgba(201, 146, 74, 0.15)',
      },
      submitButton: {
        background: 'linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%)',
        border: 'none',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-xl)',
        fontFamily: 'var(--font-ui)',
        fontSize: '0.875rem',
        fontWeight: 500,
        letterSpacing: '0.05em',
        textTransform: 'uppercase',
        color: 'var(--cream-50)',
        cursor: 'pointer',
        transition: 'all var(--transition-base)',
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 20px rgba(201, 146, 74, 0.25)',
        minHeight: '48px',
      },
      submitButtonDisabled: {
        background: 'var(--bg-elevated)',
        color: 'var(--text-muted)',
        cursor: 'not-allowed',
        boxShadow: 'none',
      },
      submitButtonHover: {
        transform: 'translateY(-2px)',
        boxShadow: '0 6px 30px rgba(201, 146, 74, 0.35)',
      },

      // Cost estimate display (Issue #4)
      costEstimate: {
        marginTop: 'var(--space-sm)',
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        color: 'var(--text-muted)',
        display: 'flex',
        alignItems: 'center',
        gap: 'var(--space-md)',
        flexWrap: 'wrap',
      },
      costBadge: {
        background: 'var(--accent-gold-subtle)',
        padding: '2px 8px',
        borderRadius: 'var(--border-radius-sm)',
        color: 'var(--accent)',
      },

      // Progress section - Redesigned (Issue #11)
      progressSection: {
        marginBottom: 'var(--space-xl)',
        position: 'relative',
      },
      // Progress bar at top (Option B from Issue #11)
      progressBar: {
        position: 'fixed',
        top: '60px',
        left: 0,
        right: 0,
        height: '3px',
        background: 'var(--bg-deep)',
        zIndex: 99,
        overflow: 'hidden',
      },
      progressBarFill: {
        height: '100%',
        background: 'linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%)',
        transition: 'width 0.5s cubic-bezier(0.16, 1, 0.3, 1)',
        boxShadow: '0 0 10px var(--accent)',
      },
      // Centered status card
      statusCard: {
        background: 'var(--bg-card)',
        borderRadius: 'var(--border-radius)',
        border: '1px solid var(--border-subtle)',
        padding: 'var(--space-lg) var(--space-xl)',
        textAlign: 'center',
        position: 'relative',
        overflow: 'hidden',
      },
      statusPhase: {
        fontFamily: 'var(--font-display)',
        fontSize: 'clamp(1.25rem, 3vw, 1.5rem)',
        fontWeight: 400,
        color: 'var(--text-primary)',
        marginBottom: 'var(--space-xs)',
      },
      statusMessage: {
        fontFamily: 'var(--font-ui)',
        fontSize: '0.9375rem',
        color: 'var(--text-secondary)',
        marginBottom: 'var(--space-md)',
      },
      statusMeta: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        color: 'var(--text-muted)',
      },
      // Phase steps indicator
      phaseSteps: {
        display: 'flex',
        justifyContent: 'center',
        gap: 'var(--space-xs)',
        marginTop: 'var(--space-md)',
      },
      phaseStep: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: 'var(--navy-600)',
        transition: 'all var(--transition-base)',
      },
      phaseStepActive: {
        background: 'var(--accent)',
        boxShadow: '0 0 8px var(--accent)',
      },
      phaseStepComplete: {
        background: 'var(--success)',
      },
      // Collapsible details toggle
      detailsToggle: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        textTransform: 'uppercase',
        letterSpacing: '0.1em',
        color: 'var(--text-muted)',
        background: 'none',
        border: 'none',
        cursor: 'pointer',
        padding: 'var(--space-sm)',
        marginTop: 'var(--space-md)',
        transition: 'color var(--transition-fast)',
      },

      // Log section - collapsible (Issue #11)
      logSection: {
        marginBottom: 'var(--space-xl)',
        overflow: 'hidden',
        transition: 'max-height var(--transition-slow)',
      },
      logSectionCollapsed: {
        maxHeight: 0,
      },
      logContainer: {
        background: 'var(--bg-secondary)',
        borderRadius: 'var(--border-radius-sm)',
        border: '1px solid var(--border-subtle)',
        padding: 'var(--space-md)',
        maxHeight: '160px',
        overflowY: 'auto',
      },
      logEntry: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        lineHeight: 1.8,
        display: 'flex',
        gap: 'var(--space-sm)',
      },
      logTimestamp: {
        color: 'var(--text-muted)',
        flexShrink: 0,
        opacity: 0.6,
      },
      logMessage: {
        color: 'var(--text-secondary)',
      },
      logSuccess: {
        color: 'var(--success)',
      },
      logError: {
        color: 'var(--error)',
      },
      logInfo: {
        color: 'var(--text-secondary)',
      },

      // Error display
      errorBox: {
        background: 'var(--error-subtle)',
        border: '1px solid rgba(176, 84, 84, 0.3)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-lg)',
        marginBottom: 'var(--space-xl)',
        fontFamily: 'var(--font-ui)',
        fontSize: '0.875rem',
        color: 'var(--error)',
      },

      // Results section
      resultsSection: {
        marginTop: 'var(--space-xl)',
      },
      resultCard: {
        background: 'var(--bg-card)',
        borderRadius: 'var(--border-radius)',
        border: '1px solid var(--border-subtle)',
        overflow: 'hidden',
      },
      resultHeader: {
        padding: 'var(--space-md) var(--space-lg)',
        borderBottom: '1px solid var(--border-subtle)',
      },
      resultTitle: {
        fontFamily: 'var(--font-display)',
        fontSize: 'clamp(1.25rem, 3vw, 1.75rem)',
        fontWeight: 400,
        color: 'var(--text-primary)',
        marginBottom: 'var(--space-xs)',
        lineHeight: 1.3,
      },
      resultMeta: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        color: 'var(--text-muted)',
        display: 'flex',
        flexWrap: 'wrap',
        gap: 'var(--space-sm)',
      },
      costDisplay: {
        background: 'var(--success-subtle)',
        padding: '2px 6px',
        borderRadius: 'var(--border-radius-sm)',
        color: 'var(--success)',
      },

      // Tabs - swipeable on mobile (Issue #7)
      tabsContainer: {
        display: 'flex',
        borderBottom: '1px solid var(--border-subtle)',
        background: 'var(--bg-secondary)',
        overflowX: 'auto',
        WebkitOverflowScrolling: 'touch',
        scrollbarWidth: 'none',
        msOverflowStyle: 'none',
      },
      tab: {
        padding: 'var(--space-md) var(--space-lg)',
        fontFamily: 'var(--font-ui)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        background: 'transparent',
        border: 'none',
        borderBottom: '2px solid transparent',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        marginBottom: '-1px',
        whiteSpace: 'nowrap',
        minHeight: '48px',
        flex: 1,
        textAlign: 'center',
      },
      tabActive: {
        color: 'var(--text-primary)',
        borderBottomColor: 'var(--accent)',
      },

      // Controls row - responsive (Issue #7)
      controlsRow: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: 'var(--space-sm) var(--space-md)',
        borderBottom: '1px solid var(--border-subtle)',
        background: 'var(--bg-secondary)',
        flexWrap: 'wrap',
        gap: 'var(--space-sm)',
      },
      controlButton: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        padding: 'var(--space-sm) var(--space-md)',
        background: 'transparent',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        color: 'var(--text-secondary)',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        textDecoration: 'none',
        display: 'inline-flex',
        alignItems: 'center',
        gap: 'var(--space-xs)',
        minHeight: '36px',
      },
      controlButtonHover: {
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },
      controlButtonActive: {
        background: 'var(--accent-gold-subtle)',
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },
      downloadButtons: {
        display: 'flex',
        gap: 'var(--space-sm)',
        flexWrap: 'wrap',
      },
      resetButton: {
        background: 'transparent',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-sm) var(--space-lg)',
        fontFamily: 'var(--font-ui)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        minHeight: '44px',
      },
      resetButtonHover: {
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },

      // Content area - optimized for mobile reading (Issue #7)
      contentArea: {
        padding: 'var(--space-md)',
        maxHeight: 'calc(100vh - 300px)',
        minHeight: '200px',
        overflowY: 'auto',
        WebkitOverflowScrolling: 'touch',
      },
      rawContent: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        lineHeight: 1.7,
        color: 'var(--text-secondary)',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word',
      },

      // Footer - responsive (Issue #7)
      footer: {
        borderTop: '1px solid var(--border-subtle)',
        padding: 'var(--space-lg) var(--space-md)',
        marginTop: 'auto',
      },
      footerInner: {
        maxWidth: '1200px',
        margin: '0 auto',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        flexWrap: 'wrap',
        gap: 'var(--space-sm)',
      },
      footerText: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        color: 'var(--text-muted)',
      },
      footerLinks: {
        display: 'flex',
        gap: 'var(--space-md)',
      },
      footerLink: {
        fontFamily: 'var(--font-ui)',
        fontSize: '0.8125rem',
        color: 'var(--text-secondary)',
        textDecoration: 'none',
        transition: 'color 0.2s ease',
        minHeight: '44px',
        display: 'flex',
        alignItems: 'center',
      },
    };

    // Global styles for markdown preview
    const markdownStyles = `
      .markdown-preview {
        font-family: var(--font-sans);
        font-size: 0.9375rem;
        line-height: 1.8;
        color: var(--text-secondary);
      }
      .markdown-preview h1,
      .markdown-preview h2,
      .markdown-preview h3 {
        font-family: var(--font-serif);
        color: var(--text-primary);
        font-weight: 400;
        margin-top: var(--space-xl);
        margin-bottom: var(--space-md);
        line-height: 1.3;
      }
      .markdown-preview h1 {
        font-size: 1.75rem;
        padding-bottom: var(--space-sm);
        border-bottom: 1px solid var(--border-subtle);
      }
      .markdown-preview h2 {
        font-size: 1.375rem;
      }
      .markdown-preview h3 {
        font-size: 1.125rem;
        font-style: italic;
      }
      .markdown-preview p {
        margin-bottom: var(--space-md);
      }
      .markdown-preview strong {
        color: var(--text-primary);
        font-weight: 600;
      }
      .markdown-preview em {
        font-style: italic;
      }
      .markdown-preview code {
        font-family: var(--font-mono);
        font-size: 0.875em;
        background: var(--bg-elevated);
        padding: 2px 6px;
        border-radius: var(--border-radius-sm);
        color: var(--accent-light);
      }
      .markdown-preview pre {
        background: var(--bg-deep);
        border: 1px solid var(--navy-700);
        border-radius: var(--border-radius);
        padding: var(--space-md);
        overflow-x: auto;
        margin-bottom: var(--space-md);
      }
      .markdown-preview pre code {
        background: transparent;
        padding: 0;
        color: var(--text-secondary);
      }
      .markdown-preview ul,
      .markdown-preview ol {
        margin-bottom: var(--space-md);
        padding-left: var(--space-lg);
      }
      .markdown-preview li {
        margin-bottom: var(--space-xs);
      }
      .markdown-preview li::marker {
        color: var(--accent);
      }
      .markdown-preview blockquote {
        font-family: var(--font-serif);
        font-style: italic;
        border-left: 3px solid var(--accent);
        padding-left: var(--space-md);
        margin: var(--space-md) 0;
        color: var(--text-secondary);
      }
      .markdown-preview a {
        color: var(--accent);
        text-decoration: underline;
        text-decoration-color: rgba(201, 146, 74, 0.4);
        text-underline-offset: 3px;
        transition: text-decoration-color var(--transition-fast);
      }
      .markdown-preview a:hover {
        text-decoration-color: var(--accent);
      }
      .markdown-preview hr {
        border: none;
        border-top: 1px solid var(--border-subtle);
        margin: var(--space-xl) 0;
      }
    `;

    // ============================================================================
    // Waveform Component
    // ============================================================================

    const Waveform = ({ isActive, phase }) => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      const timeRef = useRef(0);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = rect.height;

        const draw = () => {
          timeRef.current += 0.015;

          // Clear with slight fade for trail effect (using navy-800)
          ctx.fillStyle = 'rgba(22, 28, 36, 0.1)';
          ctx.fillRect(0, 0, width, height);

          if (isActive) {
            // Main waveform - using ATLAS Meridia amber-gold and success colors
            const color = phase === 'transcribing' ? '#c9924a' :
                         phase === 'extracting' ? '#6a9a70' : '#c9924a';

            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            for (let x = 0; x < width; x++) {
              const frequency = phase === 'transcribing' ? 0.025 : 0.015;
              const amplitude = phase === 'transcribing' ? 18 : 12;
              const noise = Math.sin(x * 0.08 + timeRef.current * 2.5) * 3;
              const y = height / 2 +
                       Math.sin(x * frequency + timeRef.current * 1.8) * amplitude +
                       Math.sin(x * frequency * 2 + timeRef.current * 2.2) * (amplitude * 0.4) +
                       noise;

              if (x === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Subtle glow line
            ctx.strokeStyle = `${color}22`;
            ctx.lineWidth = 6;
            ctx.stroke();
          } else {
            // Idle state - subtle flat line with minimal noise (amber-gold)
            ctx.strokeStyle = 'rgba(201, 146, 74, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
              const y = height / 2 + Math.sin(x * 0.02 + timeRef.current * 0.3) * 1;
              if (x === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();
          }

          animationRef.current = requestAnimationFrame(draw);
        };

        draw();
        return () => cancelAnimationFrame(animationRef.current);
      }, [isActive, phase]);

      return (
        <canvas
          ref={canvasRef}
          style={{
            width: '100%',
            height: '60px',
            display: 'block',
          }}
        />
      );
    };

    // ============================================================================
    // Helper Functions (Issue #4 - Cost Estimation, Issue #6 - Status Messages)
    // ============================================================================

    // Cost calculation based on ElevenLabs Scribe pricing (~$0.40/hour)
    const COST_PER_HOUR = 0.40;

    const calculateCost = (durationSeconds) => {
      if (!durationSeconds) return null;
      const hours = durationSeconds / 3600;
      const cost = hours * COST_PER_HOUR;
      return cost < 0.01 ? '< $0.01' : `~$${cost.toFixed(2)}`;
    };

    // User-friendly status messages (Issue #6)
    const getStatusMessage = (phase, rawMessage) => {
      const friendlyMessages = {
        'download': {
          default: 'Fetching video information...',
          patterns: [
            { match: /download/i, message: 'Downloading audio from YouTube...' },
            { match: /extract/i, message: 'Extracting audio track...' },
            { match: /fetch/i, message: 'Fetching video details...' },
          ]
        },
        'transcribing': {
          default: 'Converting speech to text...',
          patterns: [
            { match: /chunk/i, message: 'Processing audio segments...' },
            { match: /whisper/i, message: 'Analyzing audio with Whisper AI...' },
            { match: /scribe|elevenlabs/i, message: 'Transcribing with ElevenLabs Scribe...' },
            { match: /send/i, message: 'Sending audio to transcription service...' },
            { match: /progress|%/i, message: 'Transcribing speech to text...' },
          ]
        },
        'extracting': {
          default: 'Generating insights with AI...',
          patterns: [
            { match: /claude/i, message: 'Analyzing content with Claude AI...' },
            { match: /gpt|openai/i, message: 'Generating summary with GPT...' },
            { match: /extract/i, message: 'Extracting key insights...' },
            { match: /summar/i, message: 'Creating your summary...' },
          ]
        },
        'complete': {
          default: 'All done! Your content is ready.',
          patterns: []
        }
      };

      const phaseConfig = friendlyMessages[phase] || { default: rawMessage, patterns: [] };

      if (rawMessage) {
        for (const { match, message } of phaseConfig.patterns) {
          if (match.test(rawMessage)) return message;
        }
      }

      return phaseConfig.default;
    };

    // Phase display names
    const getPhaseDisplayName = (phase) => {
      const names = {
        'download': 'Downloading',
        'transcribing': 'Transcribing',
        'extracting': 'Summarizing',
        'complete': 'Complete',
      };
      return names[phase] || phase;
    };

    // Progress percentage calculation
    const getProgressPercent = (phase, phases) => {
      const phaseIndex = phases.indexOf(phase);
      if (phaseIndex === -1) return 0;
      if (phase === 'complete') return 100;
      // Each phase is ~25% (download, transcribe, extract, complete)
      return Math.min(95, (phaseIndex + 1) * 25);
    };

    // ============================================================================
    // Phase Steps Component (Issue #5 - Improved visualization)
    // ============================================================================

    const PhaseSteps = ({ currentPhase, phases }) => {
      const phaseIndex = phases.indexOf(currentPhase);

      return (
        <div style={styles.phaseSteps}>
          {phases.map((phase, i) => (
            <div
              key={phase}
              style={{
                ...styles.phaseStep,
                ...(i < phaseIndex ? styles.phaseStepComplete : {}),
                ...(i === phaseIndex ? styles.phaseStepActive : {}),
              }}
              title={getPhaseDisplayName(phase)}
            />
          ))}
        </div>
      );
    };

    // ============================================================================
    // Log Entry Component
    // ============================================================================

    const LogEntry = ({ timestamp, message, type }) => (
      <div style={styles.logEntry}>
        <span style={styles.logTimestamp}>{timestamp}</span>
        <span style={{
          ...styles.logMessage,
          ...(type === 'success' ? styles.logSuccess : {}),
          ...(type === 'error' ? styles.logError : {}),
          ...(type === 'info' ? styles.logInfo : {}),
        }}>
          {message}
        </span>
      </div>
    );

    // ============================================================================
    // Main App
    // ============================================================================

    function TranscriptPipeline() {
      const [url, setUrl] = useState('');
      const [isProcessing, setIsProcessing] = useState(false);
      const [currentPhase, setCurrentPhase] = useState(null);
      const [currentMessage, setCurrentMessage] = useState('');
      const [logs, setLogs] = useState([]);
      const [results, setResults] = useState(null);
      const [error, setError] = useState(null);
      const [config, setConfig] = useState(null);
      const [currentJobId, setCurrentJobId] = useState(null);
      const [previewMode, setPreviewMode] = useState(true);
      const [activeTab, setActiveTab] = useState('transcript');
      const [inputFocused, setInputFocused] = useState(false);
      const [buttonHovered, setButtonHovered] = useState(false);
      const [hoveredControl, setHoveredControl] = useState(null);
      const [showDetails, setShowDetails] = useState(false);
      const [isMobileView, setIsMobileView] = useState(isMobile());
      const [videoDuration, setVideoDuration] = useState(null);

      const phases = ['download', 'transcribing', 'extracting', 'complete'];

      // Handle responsive layout
      useEffect(() => {
        const handleResize = () => setIsMobileView(isMobile());
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      // Touch swipe gesture support for tab switching (Issue #7)
      const touchStartX = useRef(null);
      const handleTouchStart = (e) => {
        touchStartX.current = e.touches[0].clientX;
      };
      const handleTouchEnd = (e) => {
        if (!touchStartX.current || !results) return;
        const touchEndX = e.changedTouches[0].clientX;
        const diff = touchStartX.current - touchEndX;
        const threshold = 50; // minimum swipe distance

        if (Math.abs(diff) > threshold) {
          if (diff > 0 && results.summary && activeTab === 'transcript') {
            // Swipe left - go to summary
            setActiveTab('summary');
          } else if (diff < 0 && activeTab === 'summary') {
            // Swipe right - go to transcript
            setActiveTab('transcript');
          }
        }
        touchStartX.current = null;
      };

      useEffect(() => {
        api.getConfig()
          .then(setConfig)
          .catch(err => {
            console.error('Failed to load config:', err);
            setError('Cannot connect to API server. Is it running?');
          });
      }, []);

      const addLog = useCallback((message, type = 'default') => {
        const now = new Date();
        const timestamp = now.toTimeString().slice(0, 8);
        setLogs(prev => [...prev, { timestamp, message, type }]);
      }, []);

      const processVideo = async () => {
        if (!url.trim()) return;

        setIsProcessing(true);
        setLogs([]);
        setResults(null);
        setError(null);
        setVideoDuration(null);
        setCurrentMessage('Getting ready...');
        setShowDetails(false);

        try {
          addLog('Initializing pipeline...', 'default');

          const job = await api.startProcessing(url);
          setCurrentJobId(job.job_id);
          setCurrentMessage('Connecting to YouTube...');
          addLog('Started processing job', 'info');

          api.streamJobStatus(
            job.job_id,
            (data) => {
              setCurrentPhase(data.phase);

              // Capture video duration when available (Issue #4)
              if (data.metadata?.duration && !videoDuration) {
                setVideoDuration(data.metadata.duration);
              }

              if (data.message) {
                // Show friendly message (Issue #6)
                setCurrentMessage(getStatusMessage(data.phase, data.message));

                // Log technical details (collapsible)
                const logType = data.status === 'error' ? 'error' :
                               data.status === 'complete' ? 'success' : 'default';
                addLog(data.message, logType);
              }
            },
            async (data) => {
              if (data.status === 'complete') {
                setCurrentMessage('Preparing your content...');
                addLog('Processing complete, fetching results...', 'info');

                // Capture final duration
                if (data.metadata?.duration) {
                  setVideoDuration(data.metadata.duration);
                }

                try {
                  const [transcript, summary] = await Promise.all([
                    api.getTranscript(job.job_id),
                    api.getSummary(job.job_id).catch(() => null),
                  ]);
                  setResults({
                    title: data.metadata?.title || 'Untitled',
                    transcript,
                    summary,
                    metadata: data.metadata,
                  });
                  setCurrentMessage('All done!');
                  addLog('Your transcript is ready to view', 'success');
                } catch (fetchErr) {
                  setError('Failed to load results: ' + fetchErr.message);
                }
              } else if (data.status === 'error') {
                setError(data.error);
                setCurrentMessage('Something went wrong');
              }
              setIsProcessing(false);
            },
            (err) => {
              setError('Connection lost. Please try again.');
              setCurrentMessage('Connection interrupted');
              setIsProcessing(false);
            }
          );
        } catch (err) {
          setError(err.message);
          setCurrentMessage('Failed to start');
          setIsProcessing(false);
        }
      };

      const formatDuration = (seconds) => {
        if (!seconds) return '';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        if (h > 0) return `${h}h ${m}m`;
        if (m > 0) return `${m}m ${s}s`;
        return `${s}s`;
      };

      const resetPipeline = () => {
        setUrl('');
        setLogs([]);
        setResults(null);
        setError(null);
        setCurrentPhase(null);
        setCurrentMessage('');
        setCurrentJobId(null);
        setHoveredControl(null);
        setVideoDuration(null);
        setShowDetails(false);
      };

      return (
        <div style={styles.container}>
          <style>{markdownStyles}</style>

          {/* Header */}
          <header style={styles.header}>
            <div style={styles.headerInner}>
              <span style={styles.logo}>Transcript Pipeline</span>
              <nav style={styles.nav}>
                <span style={styles.navLink}>
                  <span
                    style={{
                      ...styles.statusDot,
                      background: config?.has_anthropic_key ? 'var(--success)' : 'var(--error)',
                    }}
                  />
                  {config?.has_anthropic_key ? 'Connected' : 'No API Key'}
                </span>
              </nav>
            </div>
          </header>

          {/* Hero */}
          <section style={styles.hero}>
            <div style={styles.heroContent}>
              <h1 style={styles.heroTitle}>
                Extract insights from{' '}
                <span style={styles.heroTitleAccent}>any video</span>
              </h1>
              <p style={styles.heroSubtitle}>
                Transform YouTube videos into searchable transcripts and AI-powered summaries
              </p>
            </div>
          </section>

          {/* Main Content */}
          <main style={styles.main}>
            {/* Input Section */}
            <section style={styles.inputSection}>
              <label style={styles.inputLabel}>YouTube URL</label>
              <div style={{
                ...styles.inputWrapper,
                ...(isMobileView ? styles.inputWrapperMobile : {}),
              }}>
                <input
                  type="text"
                  value={url}
                  onChange={(e) => setUrl(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && !isProcessing && processVideo()}
                  onFocus={() => setInputFocused(true)}
                  onBlur={() => setInputFocused(false)}
                  placeholder="Paste a YouTube link..."
                  disabled={isProcessing}
                  autoComplete="off"
                  autoCapitalize="off"
                  style={{
                    ...styles.input,
                    ...(inputFocused ? styles.inputFocused : {}),
                  }}
                />
                <button
                  onClick={processVideo}
                  disabled={isProcessing || !url.trim()}
                  onMouseEnter={() => setButtonHovered(true)}
                  onMouseLeave={() => setButtonHovered(false)}
                  style={{
                    ...styles.submitButton,
                    ...((isProcessing || !url.trim()) ? styles.submitButtonDisabled : {}),
                    ...(buttonHovered && !isProcessing && url.trim() ? styles.submitButtonHover : {}),
                    ...(isMobileView ? { width: '100%' } : {}),
                  }}
                >
                  {isProcessing ? 'Processing...' : 'Process'}
                </button>
              </div>
              {/* Cost estimate display (Issue #4) */}
              {config?.transcription_engine === 'elevenlabs' && (
                <div style={styles.costEstimate}>
                  <span>ElevenLabs Scribe</span>
                  <span style={styles.costBadge}>~$0.40/hour</span>
                </div>
              )}
            </section>

            {/* Progress Section - Redesigned (Issue #11) */}
            {isProcessing && (
              <>
                {/* Fixed progress bar at top */}
                <div style={styles.progressBar}>
                  <div
                    style={{
                      ...styles.progressBarFill,
                      width: `${getProgressPercent(currentPhase, phases)}%`,
                    }}
                  />
                </div>

                {/* Status card with centered content */}
                <section style={styles.progressSection}>
                  <div style={styles.statusCard}>
                    <div style={styles.statusPhase}>
                      {getPhaseDisplayName(currentPhase) || 'Starting'}
                    </div>
                    <div style={styles.statusMessage}>
                      {currentMessage}
                    </div>
                    {videoDuration && (
                      <div style={styles.statusMeta}>
                        {formatDuration(videoDuration)}
                        {config?.transcription_engine === 'elevenlabs' && (
                          <> · Est. cost: {calculateCost(videoDuration)}</>
                        )}
                      </div>
                    )}
                    <PhaseSteps currentPhase={currentPhase} phases={phases} />

                    {/* Collapsible details toggle */}
                    <button
                      onClick={() => setShowDetails(!showDetails)}
                      style={styles.detailsToggle}
                    >
                      {showDetails ? '▲ Hide Details' : '▼ Show Details'}
                    </button>
                  </div>
                </section>
              </>
            )}

            {/* Error Display */}
            {error && (
              <div style={styles.errorBox}>
                Error: {error}
              </div>
            )}

            {/* Logs - Collapsible (Issue #11) */}
            {logs.length > 0 && (isProcessing ? showDetails : true) && (
              <section style={{
                ...styles.logSection,
                ...(isProcessing && !showDetails ? styles.logSectionCollapsed : {}),
              }}>
                <label style={styles.inputLabel}>Activity Log</label>
                <div style={styles.logContainer}>
                  {logs.map((log, i) => (
                    <LogEntry key={i} {...log} />
                  ))}
                </div>
              </section>
            )}

            {/* Results */}
            {results && (
              <section style={styles.resultsSection}>
                <div style={styles.resultCard}>
                  {/* Result Header */}
                  <div style={styles.resultHeader}>
                    <h2 style={styles.resultTitle}>{results.title}</h2>
                    <div style={styles.resultMeta}>
                      {results.metadata?.author && <span>{results.metadata.author}</span>}
                      {results.metadata?.duration && (
                        <span>{formatDuration(results.metadata.duration)}</span>
                      )}
                      {/* Show actual cost (Issue #4) */}
                      {results.metadata?.duration && config?.transcription_engine === 'elevenlabs' && (
                        <span style={styles.costDisplay}>
                          {calculateCost(results.metadata.duration)}
                        </span>
                      )}
                    </div>
                  </div>

                  {/* Tabs */}
                  <div style={styles.tabsContainer}>
                    <button
                      onClick={() => setActiveTab('transcript')}
                      style={{
                        ...styles.tab,
                        ...(activeTab === 'transcript' ? styles.tabActive : {}),
                      }}
                    >
                      Transcript
                    </button>
                    {results.summary && (
                      <button
                        onClick={() => setActiveTab('summary')}
                        style={{
                          ...styles.tab,
                          ...(activeTab === 'summary' ? styles.tabActive : {}),
                        }}
                      >
                        Summary
                      </button>
                    )}
                  </div>

                  {/* Controls */}
                  <div style={styles.controlsRow}>
                    <button
                      onClick={() => setPreviewMode(!previewMode)}
                      onMouseEnter={() => setHoveredControl('preview')}
                      onMouseLeave={() => setHoveredControl(null)}
                      style={{
                        ...styles.controlButton,
                        ...(previewMode ? styles.controlButtonActive : {}),
                        ...(!previewMode && hoveredControl === 'preview' ? styles.controlButtonHover : {}),
                      }}
                    >
                      {previewMode ? '◉ Preview' : '○ Raw'}
                    </button>
                    <div style={styles.downloadButtons}>
                      <a
                        href={api.getDownloadUrl(currentJobId, 'transcript')}
                        onMouseEnter={() => setHoveredControl('download-transcript')}
                        onMouseLeave={() => setHoveredControl(null)}
                        style={{
                          ...styles.controlButton,
                          ...(hoveredControl === 'download-transcript' ? styles.controlButtonHover : {}),
                        }}
                      >
                        ↓ Transcript
                      </a>
                      {results.summary && (
                        <a
                          href={api.getDownloadUrl(currentJobId, 'summary')}
                          onMouseEnter={() => setHoveredControl('download-summary')}
                          onMouseLeave={() => setHoveredControl(null)}
                          style={{
                            ...styles.controlButton,
                            ...(hoveredControl === 'download-summary' ? styles.controlButtonHover : {}),
                          }}
                        >
                          ↓ Summary
                        </a>
                      )}
                    </div>
                  </div>

                  {/* Content - with swipe gesture support (Issue #7) */}
                  <div
                    style={styles.contentArea}
                    onTouchStart={handleTouchStart}
                    onTouchEnd={handleTouchEnd}
                  >
                    {previewMode ? (
                      <div
                        className="markdown-preview"
                        dangerouslySetInnerHTML={{
                          __html: window.marked ? window.marked.parse(
                            activeTab === 'transcript'
                              ? (results.transcript || '')
                              : (results.summary || '')
                          ) : ''
                        }}
                      />
                    ) : (
                      <pre style={styles.rawContent}>
                        {activeTab === 'transcript'
                          ? (results.transcript || '')
                          : (results.summary || '')}
                      </pre>
                    )}
                  </div>
                </div>

                {/* Reset Button */}
                <div style={{ padding: 'var(--space-md) var(--space-xl)', borderTop: '1px solid var(--border-subtle)', display: 'flex', justifyContent: 'center' }}>
                  <button
                    onClick={resetPipeline}
                    onMouseEnter={() => setHoveredControl('reset')}
                    onMouseLeave={() => setHoveredControl(null)}
                    style={{
                      ...styles.resetButton,
                      ...(hoveredControl === 'reset' ? styles.resetButtonHover : {}),
                    }}
                  >
                    Process Another Video
                  </button>
                </div>
              </section>
            )}
          </main>

          {/* Footer */}
          <footer style={styles.footer}>
            <div style={styles.footerInner}>
              <span style={styles.footerText}>
                Transcript Pipeline v1.0
              </span>
              <div style={styles.footerLinks}>
                <a
                  href="https://github.com/AtlasMeridia/transcript-pipeline"
                  target="_blank"
                  rel="noopener noreferrer"
                  style={styles.footerLink}
                >
                  GitHub
                </a>
              </div>
            </div>
          </footer>
        </div>
      );
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TranscriptPipeline />);
  </script>
</body>
</html>
