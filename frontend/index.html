<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transcript Pipeline</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400;1,500&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=IBM+Plex+Mono:wght@400;500&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      /* ═══════════════════════════════════════════════════════════════
         ATLAS MERIDIA DESIGN TOKENS v3.1
         ═══════════════════════════════════════════════════════════════ */

      /* Navy Scale — desaturated, slightly warm */
      --navy-950: #08090c;
      --navy-900: #0e1318;
      --navy-800: #161c24;
      --navy-700: #1e2630;
      --navy-600: #2a3440;
      --navy-500: #3d4754;

      /* Cream Scale — for light mode and accents */
      --cream-50: #f8f6f1;
      --cream-100: #f3f0ea;

      /* Background tokens */
      --bg-primary: var(--navy-900);
      --bg-secondary: var(--navy-800);
      --bg-elevated: var(--navy-700);
      --bg-card: rgba(22, 28, 36, 0.8);
      --bg-deep: var(--navy-950);

      /* Text colors — refined cream tones (WCAG AA compliant) */
      --text-primary: #d5cab8;    /* 11.5:1 contrast on navy-900 */
      --text-secondary: #bfb4a4;  /* 9.1:1 contrast on navy-900 */
      --text-muted: #a89d8e;      /* 6.5:1 contrast on navy-900, 5.3:1 on navy-700 */

      /* Amber-Gold Accent Scale */
      --accent-light: #ddb878;
      --accent: #c9924a;
      --accent-dark: #a87a3a;
      --accent-deep: #8a6530;
      --accent-gold: var(--accent);
      --accent-gold-dim: rgba(201, 146, 74, 0.6);
      --accent-gold-subtle: rgba(201, 146, 74, 0.15);
      --accent-gold-glow: rgba(201, 146, 74, 0.08);

      /* Status colors — softened */
      --success: #6a9a70;
      --success-subtle: rgba(106, 154, 112, 0.15);
      --error: #b05454;
      --error-subtle: rgba(176, 84, 84, 0.15);
      --info: #5c8ac4;

      /* Borders — using navy scale */
      --border-subtle: rgba(42, 52, 64, 0.5);
      --border-light: var(--navy-600);
      --border-color: var(--navy-600);

      /* Typography */
      --font-serif: 'Cormorant Garamond', Georgia, serif;
      --font-sans: 'DM Sans', -apple-system, sans-serif;
      --font-mono: 'IBM Plex Mono', 'JetBrains Mono', monospace;

      /* Motion tokens */
      --transition-fast: 150ms ease;
      --transition-base: 300ms ease;
      --transition-slow: 600ms cubic-bezier(0.16, 1, 0.3, 1);
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);

      /* Border radius */
      --border-radius-sm: 4px;
      --border-radius: 6px;
      --border-radius-lg: 12px;

      /* Spacing */
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 16px;
      --space-lg: 24px;
      --space-xl: 40px;
      --space-2xl: 64px;
      --space-3xl: 96px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    ::selection {
      background: rgba(201, 146, 74, 0.3);
      color: inherit;
    }

    /* Noise texture overlay */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 9999;
    }

    ::placeholder {
      color: var(--text-muted);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--text-muted);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React and Babel for development -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script type="text/babel" data-type="module">
    const { useState, useEffect, useRef, useCallback } = React;

    // ============================================================================
    // Configuration
    // ============================================================================

    const API_BASE_URL = window.location.origin;

    // ============================================================================
    // API Client
    // ============================================================================

    const api = {
      async startProcessing(url, options = {}) {
        const response = await fetch(`${API_BASE_URL}/api/process`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            url,
            llm_type: options.llmType,
            extract: options.extract !== false,
          }),
        });
        if (!response.ok) throw new Error('Failed to start processing');
        return response.json();
      },

      streamJobStatus(jobId, onUpdate, onComplete, onError) {
        const eventSource = new EventSource(`${API_BASE_URL}/api/jobs/${jobId}/stream`);

        eventSource.onmessage = (event) => {
          const data = JSON.parse(event.data);
          onUpdate(data);

          if (data.status === 'complete' || data.status === 'error') {
            eventSource.close();
            onComplete(data);
          }
        };

        eventSource.onerror = (error) => {
          eventSource.close();
          onError(error);
        };

        return () => eventSource.close();
      },

      getDownloadUrl(jobId, fileType) {
        return `${API_BASE_URL}/api/jobs/${jobId}/download/${fileType}`;
      },

      async getConfig() {
        const response = await fetch(`${API_BASE_URL}/api/config`);
        if (!response.ok) throw new Error('Failed to get config');
        return response.json();
      },

      async getTranscript(jobId) {
        const response = await fetch(`${API_BASE_URL}/api/jobs/${jobId}/transcript`);
        if (!response.ok) throw new Error('Failed to fetch transcript');
        const data = await response.json();
        return data.content;
      },

      async getSummary(jobId) {
        const response = await fetch(`${API_BASE_URL}/api/jobs/${jobId}/summary`);
        if (!response.ok) return null;  // Summary may not exist
        const data = await response.json();
        return data.content;
      },
    };

    // ============================================================================
    // Styles (CSS-in-JS)
    // ============================================================================

    const styles = {
      // Layout
      container: {
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
      },

      // Header
      header: {
        position: 'sticky',
        top: 0,
        zIndex: 100,
        background: 'rgba(14, 19, 24, 0.9)',
        backdropFilter: 'blur(12px)',
        borderBottom: '1px solid var(--border-subtle)',
      },
      headerInner: {
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '0 var(--space-lg)',
        height: '60px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
      },
      logo: {
        fontFamily: 'var(--font-serif)',
        fontSize: '1.25rem',
        fontWeight: 500,
        fontStyle: 'italic',
        color: 'var(--text-primary)',
        letterSpacing: '-0.01em',
      },
      nav: {
        display: 'flex',
        gap: 'var(--space-lg)',
        alignItems: 'center',
      },
      navLink: {
        fontFamily: 'var(--font-sans)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        textDecoration: 'none',
        transition: 'color 0.2s ease',
        cursor: 'pointer',
      },
      navLinkActive: {
        color: 'var(--text-primary)',
      },
      statusDot: {
        width: '6px',
        height: '6px',
        borderRadius: '50%',
        display: 'inline-block',
        marginRight: '6px',
      },

      // Hero section
      hero: {
        padding: 'var(--space-3xl) var(--space-lg)',
        maxWidth: '1200px',
        margin: '0 auto',
        width: '100%',
      },
      heroContent: {
        maxWidth: '720px',
      },
      heroTitle: {
        fontFamily: 'var(--font-serif)',
        fontSize: 'clamp(2.5rem, 5vw, 3.5rem)',
        fontWeight: 400,
        lineHeight: 1.15,
        marginBottom: 'var(--space-md)',
        color: 'var(--text-primary)',
      },
      heroTitleAccent: {
        background: 'linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 100%)',
        WebkitBackgroundClip: 'text',
        WebkitTextFillColor: 'transparent',
        backgroundClip: 'text',
      },
      heroSubtitle: {
        fontFamily: 'var(--font-serif)',
        fontSize: '1.25rem',
        fontStyle: 'italic',
        color: 'var(--text-secondary)',
        lineHeight: 1.5,
      },

      // Main content
      main: {
        flex: 1,
        padding: '0 var(--space-lg) var(--space-3xl)',
        maxWidth: '1200px',
        margin: '0 auto',
        width: '100%',
      },

      // Input section
      inputSection: {
        marginBottom: 'var(--space-2xl)',
      },
      inputLabel: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        textTransform: 'uppercase',
        letterSpacing: '0.1em',
        color: 'var(--text-muted)',
        marginBottom: 'var(--space-sm)',
        display: 'block',
      },
      inputWrapper: {
        display: 'flex',
        gap: 'var(--space-md)',
        alignItems: 'stretch',
      },
      input: {
        flex: 1,
        background: 'var(--bg-secondary)',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-lg)',
        fontFamily: 'var(--font-sans)',
        fontSize: '1rem',
        color: 'var(--text-primary)',
        outline: 'none',
        transition: 'border-color var(--transition-fast), box-shadow var(--transition-fast)',
      },
      inputFocused: {
        borderColor: 'var(--accent)',
        boxShadow: '0 0 0 3px rgba(201, 146, 74, 0.15)',
      },
      submitButton: {
        background: 'linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%)',
        border: 'none',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-xl)',
        fontFamily: 'var(--font-sans)',
        fontSize: '0.875rem',
        fontWeight: 500,
        letterSpacing: '0.05em',
        textTransform: 'uppercase',
        color: 'var(--cream-50)',
        cursor: 'pointer',
        transition: 'all var(--transition-base)',
        whiteSpace: 'nowrap',
        boxShadow: '0 4px 20px rgba(201, 146, 74, 0.25)',
      },
      submitButtonDisabled: {
        background: 'var(--bg-elevated)',
        color: 'var(--text-muted)',
        cursor: 'not-allowed',
        boxShadow: 'none',
      },
      submitButtonHover: {
        transform: 'translateY(-2px)',
        boxShadow: '0 6px 30px rgba(201, 146, 74, 0.35)',
      },

      // Progress section
      progressSection: {
        marginBottom: 'var(--space-2xl)',
      },
      progressHeader: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 'var(--space-md)',
      },
      progressTitle: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.6875rem',
        textTransform: 'uppercase',
        letterSpacing: '0.1em',
        color: 'var(--text-muted)',
      },
      phaseIndicator: {
        display: 'flex',
        gap: 'var(--space-lg)',
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
      },
      phase: {
        display: 'flex',
        alignItems: 'center',
        gap: 'var(--space-xs)',
        color: 'var(--text-muted)',
        transition: 'color var(--transition-base)',
      },
      phaseActive: {
        color: 'var(--accent)',
      },
      phaseComplete: {
        color: 'var(--success)',
      },
      phaseDot: {
        width: '4px',
        height: '4px',
        borderRadius: '50%',
        background: 'currentColor',
      },

      // Waveform
      waveformContainer: {
        background: 'var(--bg-secondary)',
        borderRadius: 'var(--border-radius-sm)',
        border: '1px solid var(--border-subtle)',
        padding: 'var(--space-md)',
        overflow: 'hidden',
      },

      // Log section
      logSection: {
        marginBottom: 'var(--space-2xl)',
      },
      logContainer: {
        background: 'var(--bg-secondary)',
        borderRadius: 'var(--border-radius-sm)',
        border: '1px solid var(--border-subtle)',
        padding: 'var(--space-md)',
        maxHeight: '200px',
        overflowY: 'auto',
      },
      logEntry: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        lineHeight: 1.8,
        display: 'flex',
        gap: 'var(--space-md)',
      },
      logTimestamp: {
        color: 'var(--text-muted)',
        flexShrink: 0,
      },
      logMessage: {
        color: 'var(--text-secondary)',
      },
      logSuccess: {
        color: 'var(--success)',
      },
      logError: {
        color: 'var(--error)',
      },
      logInfo: {
        color: 'var(--info)',
      },

      // Error display
      errorBox: {
        background: 'var(--error-subtle)',
        border: '1px solid rgba(176, 84, 84, 0.3)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-md) var(--space-lg)',
        marginBottom: 'var(--space-2xl)',
        fontFamily: 'var(--font-mono)',
        fontSize: '0.875rem',
        color: 'var(--error)',
      },

      // Results section
      resultsSection: {
        marginTop: 'var(--space-xl)',
      },
      resultCard: {
        background: 'var(--bg-card)',
        borderRadius: 'var(--border-radius)',
        border: '1px solid var(--border-subtle)',
        overflow: 'hidden',
      },
      resultHeader: {
        padding: 'var(--space-lg) var(--space-xl)',
        borderBottom: '1px solid var(--border-subtle)',
      },
      resultTitle: {
        fontFamily: 'var(--font-serif)',
        fontSize: '1.75rem',
        fontWeight: 400,
        color: 'var(--text-primary)',
        marginBottom: 'var(--space-xs)',
        lineHeight: 1.3,
      },
      resultMeta: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        color: 'var(--text-muted)',
      },

      // Tabs
      tabsContainer: {
        display: 'flex',
        borderBottom: '1px solid var(--border-subtle)',
        background: 'var(--bg-secondary)',
      },
      tab: {
        padding: 'var(--space-md) var(--space-xl)',
        fontFamily: 'var(--font-sans)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        background: 'transparent',
        border: 'none',
        borderBottom: '2px solid transparent',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        marginBottom: '-1px',
      },
      tabActive: {
        color: 'var(--text-primary)',
        borderBottomColor: 'var(--accent)',
      },

      // Controls row
      controlsRow: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: 'var(--space-md) var(--space-xl)',
        borderBottom: '1px solid var(--border-subtle)',
        background: 'var(--bg-secondary)',
      },
      controlButton: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        padding: 'var(--space-sm) var(--space-md)',
        background: 'transparent',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        color: 'var(--text-secondary)',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        textDecoration: 'none',
        display: 'inline-flex',
        alignItems: 'center',
        gap: 'var(--space-xs)',
      },
      controlButtonHover: {
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },
      controlButtonActive: {
        background: 'var(--accent-gold-subtle)',
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },
      downloadButtons: {
        display: 'flex',
        gap: 'var(--space-sm)',
      },
      resetButton: {
        background: 'transparent',
        border: '1px solid var(--border-color)',
        borderRadius: 'var(--border-radius-sm)',
        padding: 'var(--space-sm) var(--space-lg)',
        fontFamily: 'var(--font-sans)',
        fontSize: '0.875rem',
        color: 'var(--text-secondary)',
        cursor: 'pointer',
        transition: 'all var(--transition-fast)',
        marginTop: 'var(--space-md)',
      },
      resetButtonHover: {
        borderColor: 'var(--accent)',
        color: 'var(--accent)',
      },

      // Content area
      contentArea: {
        padding: 'var(--space-xl)',
        maxHeight: '600px',
        overflowY: 'auto',
      },
      rawContent: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.8125rem',
        lineHeight: 1.7,
        color: 'var(--text-secondary)',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word',
      },

      // Footer
      footer: {
        borderTop: '1px solid var(--border-subtle)',
        padding: 'var(--space-xl) var(--space-lg)',
        marginTop: 'auto',
      },
      footerInner: {
        maxWidth: '1200px',
        margin: '0 auto',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
      },
      footerText: {
        fontFamily: 'var(--font-mono)',
        fontSize: '0.75rem',
        color: 'var(--text-muted)',
      },
      footerLinks: {
        display: 'flex',
        gap: 'var(--space-lg)',
      },
      footerLink: {
        fontFamily: 'var(--font-sans)',
        fontSize: '0.8125rem',
        color: 'var(--text-secondary)',
        textDecoration: 'none',
        transition: 'color 0.2s ease',
      },
    };

    // Global styles for markdown preview
    const markdownStyles = `
      .markdown-preview {
        font-family: var(--font-sans);
        font-size: 0.9375rem;
        line-height: 1.8;
        color: var(--text-secondary);
      }
      .markdown-preview h1,
      .markdown-preview h2,
      .markdown-preview h3 {
        font-family: var(--font-serif);
        color: var(--text-primary);
        font-weight: 400;
        margin-top: var(--space-xl);
        margin-bottom: var(--space-md);
        line-height: 1.3;
      }
      .markdown-preview h1 {
        font-size: 1.75rem;
        padding-bottom: var(--space-sm);
        border-bottom: 1px solid var(--border-subtle);
      }
      .markdown-preview h2 {
        font-size: 1.375rem;
      }
      .markdown-preview h3 {
        font-size: 1.125rem;
        font-style: italic;
      }
      .markdown-preview p {
        margin-bottom: var(--space-md);
      }
      .markdown-preview strong {
        color: var(--text-primary);
        font-weight: 600;
      }
      .markdown-preview em {
        font-style: italic;
      }
      .markdown-preview code {
        font-family: var(--font-mono);
        font-size: 0.875em;
        background: var(--bg-elevated);
        padding: 2px 6px;
        border-radius: var(--border-radius-sm);
        color: var(--accent-light);
      }
      .markdown-preview pre {
        background: var(--bg-deep);
        border: 1px solid var(--navy-700);
        border-radius: var(--border-radius);
        padding: var(--space-md);
        overflow-x: auto;
        margin-bottom: var(--space-md);
      }
      .markdown-preview pre code {
        background: transparent;
        padding: 0;
        color: var(--text-secondary);
      }
      .markdown-preview ul,
      .markdown-preview ol {
        margin-bottom: var(--space-md);
        padding-left: var(--space-lg);
      }
      .markdown-preview li {
        margin-bottom: var(--space-xs);
      }
      .markdown-preview li::marker {
        color: var(--accent);
      }
      .markdown-preview blockquote {
        font-family: var(--font-serif);
        font-style: italic;
        border-left: 3px solid var(--accent);
        padding-left: var(--space-md);
        margin: var(--space-md) 0;
        color: var(--text-secondary);
      }
      .markdown-preview a {
        color: var(--accent);
        text-decoration: underline;
        text-decoration-color: rgba(201, 146, 74, 0.4);
        text-underline-offset: 3px;
        transition: text-decoration-color var(--transition-fast);
      }
      .markdown-preview a:hover {
        text-decoration-color: var(--accent);
      }
      .markdown-preview hr {
        border: none;
        border-top: 1px solid var(--border-subtle);
        margin: var(--space-xl) 0;
      }
    `;

    // ============================================================================
    // Waveform Component
    // ============================================================================

    const Waveform = ({ isActive, phase }) => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      const timeRef = useRef(0);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        const width = rect.width;
        const height = rect.height;

        const draw = () => {
          timeRef.current += 0.015;

          // Clear with slight fade for trail effect (using navy-800)
          ctx.fillStyle = 'rgba(22, 28, 36, 0.1)';
          ctx.fillRect(0, 0, width, height);

          if (isActive) {
            // Main waveform - using ATLAS Meridia amber-gold and success colors
            const color = phase === 'transcribing' ? '#c9924a' :
                         phase === 'extracting' ? '#6a9a70' : '#c9924a';

            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            for (let x = 0; x < width; x++) {
              const frequency = phase === 'transcribing' ? 0.025 : 0.015;
              const amplitude = phase === 'transcribing' ? 18 : 12;
              const noise = Math.sin(x * 0.08 + timeRef.current * 2.5) * 3;
              const y = height / 2 +
                       Math.sin(x * frequency + timeRef.current * 1.8) * amplitude +
                       Math.sin(x * frequency * 2 + timeRef.current * 2.2) * (amplitude * 0.4) +
                       noise;

              if (x === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Subtle glow line
            ctx.strokeStyle = `${color}22`;
            ctx.lineWidth = 6;
            ctx.stroke();
          } else {
            // Idle state - subtle flat line with minimal noise (amber-gold)
            ctx.strokeStyle = 'rgba(201, 146, 74, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x < width; x++) {
              const y = height / 2 + Math.sin(x * 0.02 + timeRef.current * 0.3) * 1;
              if (x === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.stroke();
          }

          animationRef.current = requestAnimationFrame(draw);
        };

        draw();
        return () => cancelAnimationFrame(animationRef.current);
      }, [isActive, phase]);

      return (
        <canvas
          ref={canvasRef}
          style={{
            width: '100%',
            height: '60px',
            display: 'block',
          }}
        />
      );
    };

    // ============================================================================
    // Phase Indicator Component
    // ============================================================================

    const PhaseIndicator = ({ currentPhase, phases }) => {
      const phaseIndex = phases.indexOf(currentPhase);

      const friendlyPhaseNames = {
        'download': 'Download',
        'transcribing': 'Transcribe',
        'extracting': 'Summarize',
        'complete': 'Complete',
      };

      return (
        <div style={styles.phaseIndicator}>
          {phases.map((phase, i) => (
            <div
              key={phase}
              style={{
                ...styles.phase,
                ...(i < phaseIndex ? styles.phaseComplete : {}),
                ...(i === phaseIndex ? styles.phaseActive : {}),
              }}
            >
              <span style={styles.phaseDot} />
              <span>{friendlyPhaseNames[phase] || phase}</span>
            </div>
          ))}
        </div>
      );
    };

    // ============================================================================
    // Log Entry Component
    // ============================================================================

    const LogEntry = ({ timestamp, message, type }) => (
      <div style={styles.logEntry}>
        <span style={styles.logTimestamp}>{timestamp}</span>
        <span style={{
          ...styles.logMessage,
          ...(type === 'success' ? styles.logSuccess : {}),
          ...(type === 'error' ? styles.logError : {}),
          ...(type === 'info' ? styles.logInfo : {}),
        }}>
          {message}
        </span>
      </div>
    );

    // ============================================================================
    // Main App
    // ============================================================================

    function TranscriptPipeline() {
      const [url, setUrl] = useState('');
      const [isProcessing, setIsProcessing] = useState(false);
      const [currentPhase, setCurrentPhase] = useState(null);
      const [logs, setLogs] = useState([]);
      const [results, setResults] = useState(null);
      const [error, setError] = useState(null);
      const [config, setConfig] = useState(null);
      const [currentJobId, setCurrentJobId] = useState(null);
      const [previewMode, setPreviewMode] = useState(true);
      const [activeTab, setActiveTab] = useState('transcript');
      const [inputFocused, setInputFocused] = useState(false);
      const [buttonHovered, setButtonHovered] = useState(false);
      const [hoveredControl, setHoveredControl] = useState(null);

      const phases = ['download', 'transcribing', 'extracting', 'complete'];

      useEffect(() => {
        api.getConfig()
          .then(setConfig)
          .catch(err => {
            console.error('Failed to load config:', err);
            setError('Cannot connect to API server. Is it running?');
          });
      }, []);

      const addLog = useCallback((message, type = 'default') => {
        const now = new Date();
        const timestamp = now.toTimeString().slice(0, 8);
        setLogs(prev => [...prev, { timestamp, message, type }]);
      }, []);

      const processVideo = async () => {
        if (!url.trim()) return;

        setIsProcessing(true);
        setLogs([]);
        setResults(null);
        setError(null);

        try {
          addLog('Getting ready...', 'dim');

          const job = await api.startProcessing(url);
          setCurrentJobId(job.job_id);
          addLog('Starting transcription', 'info');

          api.streamJobStatus(
            job.job_id,
            (data) => {
              setCurrentPhase(data.phase);
              if (data.message) {
                const logType = data.status === 'error' ? 'error' :
                               data.status === 'complete' ? 'success' : 'info';
                addLog(data.message, logType);
              }
            },
            async (data) => {
              if (data.status === 'complete') {
                addLog('Preparing your transcript', 'info');
                try {
                  const [transcript, summary] = await Promise.all([
                    api.getTranscript(job.job_id),
                    api.getSummary(job.job_id).catch(() => null),
                  ]);
                  setResults({
                    title: data.metadata?.title || 'Untitled',
                    transcript,
                    summary,
                    metadata: data.metadata,
                  });
                  addLog('Done! Your transcript is ready', 'success');
                } catch (fetchErr) {
                  setError('Failed to load results: ' + fetchErr.message);
                }
              } else if (data.status === 'error') {
                setError(data.error);
              }
              setIsProcessing(false);
            },
            (err) => {
              setError('Connection lost');
              setIsProcessing(false);
            }
          );
        } catch (err) {
          setError(err.message);
          setIsProcessing(false);
        }
      };

      const formatDuration = (seconds) => {
        if (!seconds) return '';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        if (h > 0) return `${h}h ${m}m`;
        if (m > 0) return `${m}m ${s}s`;
        return `${s}s`;
      };

      const resetPipeline = () => {
        setUrl('');
        setLogs([]);
        setResults(null);
        setError(null);
        setCurrentPhase(null);
        setCurrentJobId(null);
        setHoveredControl(null);
      };

      return (
        <div style={styles.container}>
          <style>{markdownStyles}</style>

          {/* Header */}
          <header style={styles.header}>
            <div style={styles.headerInner}>
              <span style={styles.logo}>Transcript Pipeline</span>
              <nav style={styles.nav}>
                <span style={styles.navLink}>
                  <span
                    style={{
                      ...styles.statusDot,
                      background: config?.has_anthropic_key ? 'var(--success)' : 'var(--error)',
                    }}
                  />
                  {config?.has_anthropic_key ? 'Connected' : 'No API Key'}
                </span>
              </nav>
            </div>
          </header>

          {/* Hero */}
          <section style={styles.hero}>
            <div style={styles.heroContent}>
              <h1 style={styles.heroTitle}>
                Extract insights from{' '}
                <span style={styles.heroTitleAccent}>any video</span>
              </h1>
              <p style={styles.heroSubtitle}>
                Transform YouTube videos into searchable transcripts and AI-powered summaries
              </p>
            </div>
          </section>

          {/* Main Content */}
          <main style={styles.main}>
            {/* Input Section */}
            <section style={styles.inputSection}>
              <label style={styles.inputLabel}>YouTube URL</label>
              <div style={styles.inputWrapper}>
                <input
                  type="text"
                  value={url}
                  onChange={(e) => setUrl(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && !isProcessing && processVideo()}
                  onFocus={() => setInputFocused(true)}
                  onBlur={() => setInputFocused(false)}
                  placeholder="https://youtube.com/watch?v=..."
                  disabled={isProcessing}
                  style={{
                    ...styles.input,
                    ...(inputFocused ? styles.inputFocused : {}),
                  }}
                />
                <button
                  onClick={processVideo}
                  disabled={isProcessing || !url.trim()}
                  onMouseEnter={() => setButtonHovered(true)}
                  onMouseLeave={() => setButtonHovered(false)}
                  style={{
                    ...styles.submitButton,
                    ...((isProcessing || !url.trim()) ? styles.submitButtonDisabled : {}),
                    ...(buttonHovered && !isProcessing && url.trim() ? styles.submitButtonHover : {}),
                  }}
                >
                  {isProcessing ? 'Processing...' : 'Process'}
                </button>
              </div>
            </section>

            {/* Progress Section */}
            {(isProcessing || logs.length > 0) && (
              <section style={styles.progressSection}>
                <div style={styles.progressHeader}>
                  <span style={styles.progressTitle}>Processing</span>
                  {currentPhase && <PhaseIndicator currentPhase={currentPhase} phases={phases} />}
                </div>
                <div style={styles.waveformContainer}>
                  <Waveform isActive={isProcessing} phase={currentPhase} />
                </div>
              </section>
            )}

            {/* Error Display */}
            {error && (
              <div style={styles.errorBox}>
                Error: {error}
              </div>
            )}

            {/* Logs */}
            {logs.length > 0 && (
              <section style={styles.logSection}>
                <label style={styles.inputLabel}>Activity Log</label>
                <div style={styles.logContainer}>
                  {logs.map((log, i) => (
                    <LogEntry key={i} {...log} />
                  ))}
                </div>
              </section>
            )}

            {/* Results */}
            {results && (
              <section style={styles.resultsSection}>
                <div style={styles.resultCard}>
                  {/* Result Header */}
                  <div style={styles.resultHeader}>
                    <h2 style={styles.resultTitle}>{results.title}</h2>
                    <div style={styles.resultMeta}>
                      {results.metadata?.author && <span>{results.metadata.author}</span>}
                      {results.metadata?.duration && (
                        <span> · {formatDuration(results.metadata.duration)}</span>
                      )}
                    </div>
                  </div>

                  {/* Tabs */}
                  <div style={styles.tabsContainer}>
                    <button
                      onClick={() => setActiveTab('transcript')}
                      style={{
                        ...styles.tab,
                        ...(activeTab === 'transcript' ? styles.tabActive : {}),
                      }}
                    >
                      Transcript
                    </button>
                    {results.summary && (
                      <button
                        onClick={() => setActiveTab('summary')}
                        style={{
                          ...styles.tab,
                          ...(activeTab === 'summary' ? styles.tabActive : {}),
                        }}
                      >
                        Summary
                      </button>
                    )}
                  </div>

                  {/* Controls */}
                  <div style={styles.controlsRow}>
                    <button
                      onClick={() => setPreviewMode(!previewMode)}
                      onMouseEnter={() => setHoveredControl('preview')}
                      onMouseLeave={() => setHoveredControl(null)}
                      style={{
                        ...styles.controlButton,
                        ...(previewMode ? styles.controlButtonActive : {}),
                        ...(!previewMode && hoveredControl === 'preview' ? styles.controlButtonHover : {}),
                      }}
                    >
                      {previewMode ? '◉ Preview' : '○ Raw'}
                    </button>
                    <div style={styles.downloadButtons}>
                      <a
                        href={api.getDownloadUrl(currentJobId, 'transcript')}
                        onMouseEnter={() => setHoveredControl('download-transcript')}
                        onMouseLeave={() => setHoveredControl(null)}
                        style={{
                          ...styles.controlButton,
                          ...(hoveredControl === 'download-transcript' ? styles.controlButtonHover : {}),
                        }}
                      >
                        ↓ Transcript
                      </a>
                      {results.summary && (
                        <a
                          href={api.getDownloadUrl(currentJobId, 'summary')}
                          onMouseEnter={() => setHoveredControl('download-summary')}
                          onMouseLeave={() => setHoveredControl(null)}
                          style={{
                            ...styles.controlButton,
                            ...(hoveredControl === 'download-summary' ? styles.controlButtonHover : {}),
                          }}
                        >
                          ↓ Summary
                        </a>
                      )}
                    </div>
                  </div>

                  {/* Content */}
                  <div style={styles.contentArea}>
                    {previewMode ? (
                      <div
                        className="markdown-preview"
                        dangerouslySetInnerHTML={{
                          __html: window.marked ? window.marked.parse(
                            activeTab === 'transcript'
                              ? (results.transcript || '')
                              : (results.summary || '')
                          ) : ''
                        }}
                      />
                    ) : (
                      <pre style={styles.rawContent}>
                        {activeTab === 'transcript'
                          ? (results.transcript || '')
                          : (results.summary || '')}
                      </pre>
                    )}
                  </div>
                </div>

                {/* Reset Button */}
                <div style={{ padding: 'var(--space-md) var(--space-xl)', borderTop: '1px solid var(--border-subtle)', display: 'flex', justifyContent: 'center' }}>
                  <button
                    onClick={resetPipeline}
                    onMouseEnter={() => setHoveredControl('reset')}
                    onMouseLeave={() => setHoveredControl(null)}
                    style={{
                      ...styles.resetButton,
                      ...(hoveredControl === 'reset' ? styles.resetButtonHover : {}),
                    }}
                  >
                    Process Another Video
                  </button>
                </div>
              </section>
            )}
          </main>

          {/* Footer */}
          <footer style={styles.footer}>
            <div style={styles.footerInner}>
              <span style={styles.footerText}>
                Transcript Pipeline v1.0
              </span>
              <div style={styles.footerLinks}>
                <a
                  href="https://github.com/AtlasMeridia/transcript-pipeline"
                  target="_blank"
                  rel="noopener noreferrer"
                  style={styles.footerLink}
                >
                  GitHub
                </a>
              </div>
            </div>
          </footer>
        </div>
      );
    }

    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TranscriptPipeline />);
  </script>
</body>
</html>
